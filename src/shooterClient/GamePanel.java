package shooterClient;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.ListIterator;
import java.util.Random;

import javax.swing.JPanel;
import javax.swing.Timer;

public class GamePanel extends JPanel{
        /** Stores the insets for the frame. Used when calculating the starting position of the player's ship.*/
        private Insets gpInsets; 
        /**stores the end game message*/
        private String message = ""; 
        /**checks if one of the end game conditions has been met*/
        private boolean isRunning; 
        
        
        //GamePanel constructor. SetFocusable has to be set to true for the panel to respond to player's input.
        public GamePanel () {
                isRunning = true; 
                setBackground(Color.BLACK);
                gpInsets = getInsets(); 
                player = new PlayersShip(5, "playerShip1_blue.png", gpInsets.bottom, 5);
                setFocusable(true);
        }
       
        /**
    	 * CHANGED
    	 * @param g Graphics component object received from the JVM.  
    	 * Method renders one "frame" of the animation
    	 */
    	@Override
    	public void paintComponent(Graphics g) {
    		super.paintComponent(g);
    		//if a player's ship was not destroyed, draw it on the screen.
    		if(isRunning){
    			if(player != null)
    				g.drawImage(player.resizedSprite, player.objectPosition.x, player.objectPosition.y, null);
    			//the for loops iterate through all enemy ships, updating their positions and redrawing them
    			for(int i=0; i<5; i++){
    				for(int j=0; j<7; j++){
    					if(enemies[i][j]!=null){
    						if(i%2==0)
    							enemies[i][j].moveLeft();
    						else if(i%2==1)
    							enemies[i][j].moveRight();
    						g.drawImage(enemies[i][j].getImage(), enemies[i][j].objectPosition.x, enemies[i][j].objectPosition.y, null);
    					}
    				}
    			}
    			//draw any existing bullets onto the panel; ignore null references  
    			if(!bullets.isEmpty()){
    				for(Bullet i: bullets){
    					if(i!=null)
    						g.drawImage(i.resizedSprite, i.objectPosition.x, i.objectPosition.y, null);
    				}
    			}
    		} else {
    			g.setColor(Color.BLUE);
    			g.setFont(new Font(null, Font.BOLD, 72));
    			g.drawString(message, 55, 200);
    		}
    	}
    	
    	/**
    	 *CHANGED
    	 *@param e ActionEvent generated by the ticks of the timer. 
    	 * This method responds to all actionPerformed events. 
    	 */
    	@Override
    	public void actionPerformed(ActionEvent e) {
    		// if this is an event from the Timer, call the method that advances the animation
    		if (e.getSource() == t) {
    			if(isRunning)
    				tick();
    			repaint(); 
    		}
    	}

    	/**
    	 *CHANGED
    	 *Method is responsible for updating all the objects on the screen after each tick of the timer.  
    	 *Unused null references are removed and positions of all objects are recalculated. 
    	 */
    	private void tick() {
    		//check if all enemies are dead
    		if(!generatorOfEvil.enemiesExist()){
    			isRunning = false; 
    			message = "You  Win!";
    			return; 
    		}
    		//Cleans up the bullets arrays by stepping through it using the List Iterator
    		//If a Bullet reference was set to null or the update function fails, the element gets excised   
    		if(!bullets.isEmpty()){
    			ListIterator <Bullet> iter = bullets.listIterator(); 
    			while(iter.hasNext()){
    				Bullet bul = iter.next();
    				if(bul==null || !bul.updatePosition())
    					iter.remove();
    			}
    		}
    		//uncomment to track the size of the bullet array in the console
    		//System.out.println(bullets.size());
    	
    		//invokes EnemySpawners collision checker
    		generatorOfEvil.collisionChecker(bullets);
    		//kill the player if the ship collided with the enemy's bullet
    		if(player.collisionChecker(bullets)){
    			player = null; 
    			isRunning = false;
    			message = "You Lose!";
    			return; 
    		}
    		//increment the delay counters 
    		bulletDelay++; 
    		enemyDelay++; 
    		//replace magic number 60 with a variable 
    		//choose a random column and have an enemy fire from it
    		if(enemyDelay>60){
    			int column = randColumn.nextInt(7);  	
    			bullets.add(generatorOfEvil.enemyFire(4,column)); 
    			enemyDelay=0; 
    		}
    		// ask to have the game redrawn (this will invoke paintComponent() when the system says the time is right)
    	}
    	
    	/**
    	 * Start the Timer: this will cause events to be fired, and thus the animation to begin
    	 */
    	
    	void go() {
    		t.start();
    	}
    	/**
    	 * CHANGED
    	 * @param e accepts a KeyEvent coming from a left or right cursor arrows
    	 * Moves the ship left or right depending on user input
    	 */
    	@Override
    	public void keyPressed(KeyEvent e){
    		if(e.getKeyCode()==KeyEvent.VK_RIGHT)
    			if(player!=null)
    				player.moveRight();
    		
    		if(e.getKeyCode()==KeyEvent.VK_LEFT)
    			if(player!=null)
    				player.moveLeft(); 
    	}
    	/**
    	 * @param e is the key released event that will call the shoot method of the player's ship
    	 * if the key released was cursor up.
    	 */
    	@Override
    	public void keyReleased(KeyEvent e){
    		
    		if(e.getKeyCode()==KeyEvent.VK_UP && bulletDelay > 30){
    			bulletDelay = 0; 
    			if(player!=null)
    				bullets.add(player.shoot()); 
    		}
    		
    	}
    	//method not used. implementation forced by the interface. 
    	@Override
    	public void keyTyped(KeyEvent e){}
}
